# Table of Contents

1. [Именование классов и интерфейсов](/articles/Naming.md)
2. [Модели и компоненты](/articles/ModelsAndComponents.md)


Для того, что бы определить предметную область и не путаться, следует сразу определить термины.

TL&DR; - модели это данные, а компоненты - то, что работает с этими данными

# Модель

Моделью (Model) является структура данных (класс), созданная для содержания набора данных. 
Ближайшее определение по Фаулеру - [Value Object](https://martinfowler.com/bliki/ValueObject.html)

Модели делятся на следующие основные подтипы:

* **Модель бизнес-логики**. Используется компонентами, реализовывающими бизнес-логику приложения. 
  Модели такого типа представлены в приложении в виде интерфейсов и (необязательно) реализаций.
* **Data Transfer Object** или [DTO](https://www.martinfowler.com/eaaCatalog/dataTransferObject.html).
  Помимо данных может содержать описание правил упаковки/распаковки/сериализации,
  к примеру - иметь аннотации `@JsonProperty`. Модели данного типа могут, но не обязаны, реализовывать
  интерфейс модели бизнес-логики.
* **Database Entity Object** - аналогичен DTO, но предназначен не для передачи, а для записи или 
  чтения из базы данных. Модели данного типа могут, но не обязаны, реализовывать
  интерфейс модели бизнес-логики.

Не рекоммендуется использовать одну и ту же реализацию (класс) в качестве моделей разных типов, 
другими словами - не стоит на одну и ту же модель гонять и в базу данных и по сети. 
Есть только одно исключение - если модель типа DTO/Entity имеет техническую возможность
реализовывать интерфейс модели бизнес-логики, то она может это делать и  выполнять 
по-сути две роли одновременнно.

В случае использоваия Java все модели бизнес логики обязаны реализовывать `equals` и `hashCode`.
И если DTO/Entity реализовывают интерфейс модели бизнес-логики, они также обязаны
удовлетворять этому правилу.

# Компонента

Компонентой (Component) называется класс, выполняющий работу над данными моделей. Другими словами - 
компоненты обеспечивают выполнение бизнес логики, либо реализовывают абстракции, необходимые для
работы бизнес-логики. 

Помимо компонент, выполняющих непосредственно бизнес-логику, можно выделить следующие типы 
служебных компонент (список неполон):

* **Репозитарии** (Repositories) - берут на себя роль обеспечения персистентности данных. Умеют 
  читать и/или писать используя различные источники (базы) данных. Работают с моделями 
  бизнес-логики, но внутри используют Entity.
* **Клиенты** (Clients) - ответственные за коммуникацию с другими сервисами. Работают с моделями 
  бизнес-логики, но внутри используют DTO.
* **Билдеры** (Builders) - отдельный класс компонент, использующихся для построения моделей 
  (к примеру если модель большая, а декомпозицию сделать нельзя). К билдерам применяется одно 
  очень важное правило - их нельзя передавать за границы метода, их использующего. Правило 
  позволяет уменьшить отрицательный эффект от использования мутабельных компонент, которыми
  и являются билдеры.
* **Обвязки** - прокси объекты, адаптеры и прочий сахар, упрощающий интеграцию с библиотеками или
  жизнь разработчика. Если брать шире, то все вышеперечисленные компоненты, кроме компонент
  бизнес-логики, являются обвязками.

Следует избегать передачи компонент агрументами при вызове других компонент, кроме тех случаев, 
когда компонента была специально для этого спроектирована. Зачастую в случае сложной составной логики
множество компонент передаются в конструктор, либо инстанциируются там же используя остальные
входящие данные конструктора.

Компоненты обязаны иметь контракт в виде интерфейса. Исключение составляют следующие случаи:

* Компонента приватна - используется модификатор `private` либо package local в случае Java.
* Предъявлена объективная причина, согласно которой компонента не может быть повторно
  использована в другом месте/контекста.

