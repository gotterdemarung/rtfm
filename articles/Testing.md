# Table of Contents

1. [Именование классов и интерфейсов](/articles/Naming.md)
2. [Модели и компоненты](/articles/ModelsAndComponents.md)
3. [Тестирование](/articles/Testing.md)


# TL&DR;

1. Тесты писать нужно
2. Разработчик не должен доверять никому, включая себя. Тесты - способ проверить себя и свой код
3. Юнит - это функция/метод класса
4. В тесте тестируется только тело юнита, остальное - мокается
5. Лямбда - это тоже мок, зачастую даже лучше мока, поставляемого фреймвоком
6. Моки обязаны проверять, что в них попадают требуемые значения
7. Тестируем и контракт и реализацию
8. HappyFlow - обязательно, остальные кейсы - если есть возможность
9. Между тестами должны быть зависимости. Лучше увидеть один упавший тест 
   и простыню скипов, чем простыню фейлов без понимания где причина
10. Тесты должны быть простыми и читаемыми. Хелперы лучше не использовать


# Тестирование

Автотесты - неотъемлемая часть любого качественно продукта. Юнит тестирование, 
о котором пойдёт речь - одно из разновидностей автотестов, реализуемое самими
разработчиками.

Юнитом в `Unit testing` считается минимальный тестируемый блок кода, чаще всего 
это - метод класса/объекта. В одном объекте/классе таких юнитов может быть
несколько, но зачастую тест пишется под класс целиком, вынося проверки
 юнитов в отдельные методы теста.

Перед тестом ставятся две цели:

1. **Proof of work** - проверка соответствия бизнес-логики 
   юнита поставленным задачам
2. **Regression check** - проверка, что новый, не относящийся к юниту 
   функционал не поменял логику работы юнита


## Предмет юнит-теста

Предметом юнит-теста является исключительно тело юнита. Из этого следует 
**главное правило написания юнит-теста** - все сущности, используемые 
юнитом, должны быть представлены (или подменены) сущностями с
гарантированными поведением.

Если юнитом является метод класса/объекта, то сущностями, которые им могут
использоваться, являются:

- **Аргументы** метода.
- **Внутренее состояние** класса/объекта, содержащего юнит, определяемое **конструктором**
- **Вызов других методов** класса, содержащего юнит


## Сущности с гарантированным поведением

Иногда предоставление сущностей с гарантированным поведением не требуется:

```java
// Unit
public int sum(final int x, final int y) {
    return x + y;
}
```

В представленном примере аргументы метода - скаляры, их поведение определено на уровне языка.

Тот же пример можно усложнить:

```java
interface IntSupplier {
    int get();

    public static class Impl implements IntSupplier {
        private final int value;

        public Impl(final int value) {this.value = value;}
        public int get() {return this.value;}
    }
}

// Unit
public int sum(final IntSupplier x, final IntSupplier y) {
    return x.get() + y.get();
}
```

В этом примере вместо скаляров на вход юнита поступают объекты,
описанные интерфейсом `IntSupplier`. Использование `IntSupplier.Impl` при 
тестировании юнита `sum` некорректно, поскольку внесение изменений в 
`IntSupplier.Impl` сломает тест юнита `sum`, а это - некорретно. Пример
такого фатального изменения `IntSupplier.Impl` - кто-то заменил 
тело функции с `public int get() {return this.value;}` на `public int get() {return 1;}` и это приведёт к падению тестов юнита `sum` для всех пар 
значений кроме `1,1`.

Для предоставления гарантированного поведения аргументов можно
использовать один из двух подходов:
1. Расположить рядом с **тестом** юнита `sum` свою реализацию
   интерфейса `IntSupplier`. В случае Java - можно реализовать интерфейс
   лямбдой прямо в теле теста или дата-провайдера.
2. Создать мок (mock) при помощи соответствущего фреймворка.

Для гарантированного поведения внутреннего состояния, задаваемого
через конструктор, можно воспользоваться теми же подходамим, однако
корректно протестировать вызов другого метода класса/объекта,
содержащего юнит, можно только используя мок (mock).


## Требования к сущностям с гарантированным поведением

Таких требований два:
1. Поведение должно быть гарантированным
2. В случае, если в сущность было передано значение, она должна 
   его проверить на соответствие ожидаемому

На втором следует остановиться подробнее, так как его тяжело понять без 
примера. Допустим есть следующая конфигурация теста:

```java
class PasswordValidator {
    private final CredentialsRepository repo;
    public PasswordValidator(final CredentialsRepository repo) {
        this.repo = repo;
    }
    // Unit
    boolean areValid(final String login, final String password) {
        return password.equals(repo.findPassword(login));
    }
}

interface CredentialsRepository {
    String findPassword(String login);
}
```

Для теста используется пара логина и пароля `admin,adminpwd`

Разработчик, пишущий тест для `PasswordValidator.areValid` написал
следующую релизацию `CredentialsRepository` для использования в тесте
(не сложно представить себе похожую реализацию в виде мока):

```java
class CredentialsRepositoryForTest {
     public String findPassword(final String login) {
         return "adminpwd";
     }
}
```

Минус его решения заключается в том, что он в своём репозитарии не
учитывает переданное значение `login`. В частности, его тест не
упадёт (хотя должен), если тело юнита изменится следующим образом:

```java
// Unit
boolean areValid(final String login, final String password) {
    return password.equals(repo.findPassword("")); // login is ignored
}
```

Корректная реализация `CredentialsRepository` могла бы иметь вид:

```java
class CredentialsRepositoryForTest {
     public String findPassword(final String login) {
         return "admin".equals(login) ? "adminpwd" : null;
     }
}
```


## Blackbox and whitebox

**Blackbox** - подход в рамках которого мы, не зная содержимое юнита,
тестируем поведение, описанное его контрактом (интерфейсом). С другой
стороны **whitebox** - это тестирование непосредственно реализации.

Пример:

```java
interface CredentialsValidator {
    boolean areValid(String login, String password);
}

public class Hardcoded implements CredentialsValidator {
    // Unit
    public boolean areValid(final String login, final String password) {
        return "admin".equals(login) && "admin".equals(password);
    }
}

public class DataSourceCredentialsValidator implements CredentialsValidator {
    private final CredentialsRepository repo;

    public DataSourceCredentialsValidator(final CredentialsRepository repo) {
        this.repo = repo;
    }

    // Unit
    public boolean areValid(final String login, final String password) {
        return password.equals(repo.findPassword(login));
    }
}

interface CredentialsRepository {
    String findPassword(String login);
}
```

В примере - две реализации `CredentialsValidator`. В случае **blackbox**
теста было бы достаточным проверить, что оба вернут `true` в случае 
передачи `admin,admin` (второму предварительно в конструкторе был бы передан репозитарий, знающий об логине `admin`). Однако в случай **whitebox** тестирования, требуется для `DataSourceCredentialsValidator` удостовериться, что был действительно вызван `CredentialsRepository.findPassword`
с требуемым значением переменной `login`.

Наиболее правильным является использование **whitebox** подхода, при 
сохранении проверок поведения, характерных для **blackbox**


## Минимальный тест

Под минимальным понимает тест, реализовывающий так называемый 
**Happy Flow** - корректную работа юнита в случае передачи корректных 
данных. С противоположной стороны полное тестирование подразумевает
передачу в рамках теста как корректных, так и некорректных данных, 
ожидая возникновения ошибки в последнем случае.


## Зависимости тестов

Большинство фреймворков для тестирования (не только юнит-тестирования) предоставляют возможность указать связи между тестами по правилу **depends on**. В случае указания такой связи, тест не будет запущен, если тест от
которого он зависит, завершился с ошибкой.

Важно грамотно структурировать тесты и назначать связи между ними. 
Как минимум имеет смысл поставить связь **depends on** между **Happy Flow** 
и тестами, предоставляющими заведомо некорректные данные - какой 
смысл тестировать поведение юнита при работе с некорректными данными,
если он не отработал правильные?

В случае, если связи между тестами не будут настроены или будут настроены 
неверно, разработчик увидит простыню упавших тестов и потратит значительное 
количество времени на определение причины.


## Сложность тестов

Тело теста должно быть максимально лаконичным. Тест не должен использовать 
свои обвязки для тестирования (какие-то функции, хелперы и т.д.). Фикстурные
данные также следует располагать рядом с телом теста, что бы иметь 
возможность визуально оценить ход теста.

Если эти правила нарушить, написать тонны обвязок и сложить фикстуры 
отдельно за тридевять земель, то тесты сами становятся юнитами, которые 
нужно тестировать.

Keep it simply stupid, иначе кто будет проверять проверяющего?


## Контроль качества юнит-теста

1. Субъективный. Тест должен быть написан, работать и пройти ревью.
2. Code coverage. Большинство тестовых фреймворков позволяют проанализировать, покрыты ли
   все логические пути внутри юнита тестами. Важно помнить, что у полного юнит теста
   будет 100% покрытие (coverage), но при этом 100% покрытие не значит, что
   юнит-тест - полный.
3. Мутационное тестирование. Этот инструмент вносит изменения в тело юнита (меняя `+` на `-`, 
   `<` на `>`, `AND` на `OR` и т.д.) ожидая, что это приведёт к нарушению работы теста.
   Если подобное изменение не повлияло на результат теста, то такой тест считается
   некорректным. На текущий момент времени мутационное тестирование является одним из
   лучших инструментов верификации тестов со 100% покрытием.