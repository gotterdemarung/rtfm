# Вступ

Мова программування Go наразі є досить зручним та потужним інструментом для розробки 
ефективних та високонавантажених серверних застосунків. Вона ідеально підходить для 
розробки CLI застосунків, мікросервісів, а при використанні IDE GoLand стає можливим
і программування систем будь-якої складності.

Семантично мова схожа на всі C-подібні мови, але всеж має деяку специфіку, взяту із
Ruby/Python, тому деякі речі можуть бути незвичними.


Ця документація призначена для Java-розробників, що мають намір познайомитися із Go.

# Зміст

* [Встановлення](#встановлення)
* [Hello world](#hello-world)
  * [Пишемо, компільюємо та запускаємо](#пишемо-компільюємо-та-запускаємо)
  * [Добавляємо текст](#добавляємо-текст)
* [Змінні](#змінні)
* [Nil](#nil)
* [Типи даних](#типи-даних)
* [Функції](#функції)

# Встановлення

На [офіційному сайті Go](https://go.dev/) можна знайти [посилання](https://go.dev/dl/) 
для завантаження Go для будь-якої платформи - Windows, Linux, MacOS. Також отримати
Go можливо за допомогою стандартних пакетних менеджерів, наприклад

- `sudo apt install golang` для Ubuntu
- `brew install golang` для MacOS

Для встановлення рекомендується версія не менша ніж `1.13`, оскільки надалі будуть 
викориростовуватися можливості що доступні починаючи саме із цієї версії.

Корректність установки можна перевірити за допомогою команди `go version`:

```
$ go version
go version go1.18 linux/amd64
```

❗**Go має бути встановлено лише на машині розробника. Після компіляції застосунок 
можна запускати будь-де без встановленого Go.**

# Hello world

## Пишемо, компільюємо та запускаємо
Код, написаний на мові Go розміщується у файлах із розширенням `.go`. Як і в Java, 
код структурований по пакетам і папкам, але у Go не обов'язково, щоб назва папки 
та пакету співпадали (але це дуже бажано). Точкою входу є місцевий аналог 
`public static void main(String args)`, що виглядає наступним чином:
1. Назва пакету - `main`
2. Назва методу - `main`
3. Метод не має аргументів та возврату

Сторимо файл `foo.go`, що задовольняє усім вимогам:

```go
package main

func main() {
}
```

Хоча код і не виконує що-небудь, це - валідний код на Go. 
Для того, щоб скомпілювати його, треба виконати команду `go build foo.go`, в результаті
чого буде створено executable файл `foo` у тій самій директорії. Ім'я можна задати
будь-яке за допомогою флагу `-o`, наприклад `go build -o helloworld foo.go`.

Після компіляції отриманий файл можно запустити як і будь-який інший бінарь
за допомогою `./foo`. Якщо це зробити - команда очіковано не зробить нічного, 
оскільки логіку в код ми ще не добавляли.

Насправді під час розробки Go-девелопери **ніколи не використорують команду** `go build`.
Замість цього повсякчас використовується команда `go run` що робить наступне
1. Компілює наш код в папку `/tmp` або аналог
2. Запускає скомпільований файл
3. Після завершення видаляє створений файл.

Для нашого випадку достатньо запускати наш файл командою `go run foo.go`

## Добавляємо текст

В Go немає прямого аналогу `System.out.Print`. Але цю роль, та багато інших цікавих
штук може виконувати пакет стандартного форматування `fmt` - саме в ньому знаходяться
`fmt.Println`, `fmt.Printf` а також `fmt.Sprint` (що є аналогом `String.format`).
Як і в Java, в Go для того, щоб використати код із пакету, його треба проімпортувати 
за допомогою команди `import`:

```go
package main

import "fmt"

func main() {
}
```

Якщо добавити `import` та спробувати запустити, ми отримаємо несподівану для своту Java
помилку:

```
$ go run foo.go
./foo.go:3:8: imported and not used: "fmt"
```

Go не дозволяе імпортувати будь-що "просто так" - обов'язково треба використати 
проімпортований пакет:

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!") // Крапки з комою немає !
}
```

Тепер наш застосунок компілюється і запускається так, як і очікувалось:
```
$ go run foo.go
Hello, world!
```

❗ **Важливо**. 

Правило використовувати проімпортоване в Go є дуже важливим, оскільки весь рантайм та 
стандартний інструментарій подрібнений на пакети і у фінальний бінарь попадають лише
ті, що використовуються у застосунку. Тобто якщо наш застосунок не буде 
використовувати пакет `fmt`, то його взагалі не буде в результуючому бінарі і не можна
буде десь щось дістати навіть за допомогою рефлексії. Навіть якщо у вашому застосунку
буде пакет (папка) із кодом, що не використовується в інших його частинах та функції
`main`, то він не буде скомпільований і не попаде у фінальний бінарь.

До речі, переконатися в правдивості твердження про відсутність `fmt` можна просто 
порівнявши розміри скомпільованих файлів:

```
-rwxrwxr-x user user 1758353 foo    [+FMT] <-- файл у півтора рази більше
-rwxrwxr-x user user 1154527 foo    [-FMT]
```

# Змінні

Найпоширеннішим способом оголошення змінної в Go є оголошення із автоматичним виведенням
типу (у Java аналогом є ключове слово `var`). Для цього в Go використовується оператор 
`:=`, наприклад `name := "Some name"`.

Тепер можна параметризувати наш застосунок за допомогою змінної:

```go
package main

import "fmt"

func main() {
	name := "World"
	fmt.Println("Hello, "+name+"!")
}
```

❗ **Важливо**. 

Go зобов'язує розробника використовувати оголошені змінні. Тобто не
можна оголосити `someValue := "foo"` а потім не використати змінну `someValue` - 
застосунок не скомпілюється

# Nil

В Java є `null`, в Go є `nil`. В принціпе, це все, деталі незначні.

# Типи даних

Усі стандартні типи даних у Go можна розділити на два типи:
1. **Референсні** (як ті що в Java на хіпі) - ті, що мають дефолт `nil` - массиви, слайси, 
   мапи, канали, вказівники та **функції**
2. **Структури** - це місцеві об'єкти, вони не референсні та не мають конструкторів, щодо
   них пізніше
3. **Примітивні** (як ті що в Java на стеку):

- Числові типи
- - Знакові
- - - `int` - 32/64 bits, залежить від платформи 
- - - `int8`, `int16`, `int32`, `int64`
- - Беззнакові
- - - `uint` - 32/64 bits, залежить від платформи 
- - - `uint8`, `uint16`, `uint32`, `uint64`
- - - `uintptr`
- - Із рухомою комою, знакові
- - - `float32`, `float64`
- - Комплексні
- - - `complex64`, `complex128`
- - `bool`
- - `byte`
- - `rune` - одна літера, схоже на Java `char`
- - `string` - строка, на відмінність від Java не може бути `nil`

Основний числовий тип даних, що застосовується в автоматичному виведенні типу це `int`. Тобто конструкція
`i := 0` оголосить змінну з типом `int`.

На відміну від Java, тут немає боксових різновидів типів даних, більш того навіть у `string` тут немає
методів/функцій. 

# Функції

Для оголошення функції використовується ключове слово `func` і ми насправді вже робили
це, оголошуючи головну функцію `main` у [Hello world](#hello-world). Із функціями у Go
є дуже багато специфіки, тому потроху почнемо знайомитися.

До цього ми використовували функцію без аргументів та повернення результатів. У Go, як
і в усіх поважаючих себе мовах, є можливість це робити:

```go
func sum(a int, b int, c int) int {
    return a + b + c
}
```

Зверніть увагу, що тип даних тут вказується після назви вхідної змінної, а не перед, як
це зроблено в Java. Завдяки цьому у випадку, якщо змінні одного типу, тип можна вказувати
один раз:

```go
func sum(a, b, c int) int {
    return a + b + c
}
```

Також супер важливим є те, що Go дозволяє повертати не одне, а будь-яку кількість значень:

```go 
func minMax(a, b int) (int, int) {
    if a >= b {
        return b, a
    }
    return a, b
}

func main() {
    min, max := minMax(10, 8)
    // TODO do something with variables min and max
}
```

Також щоб не заплутатись є можливість вказувати імена для вихіндних значень, однакові типи
також можна не повторювати:

```go 
func minMax(a, b int) (min, max int) {
    if a >= b {
        return b, a
    }
    return a, b
}
```

Оскільки кострукція `(min, max int)` не є декоративною а насправді оголошує змінні, це дозволяє
робити так:

```go 
func minMax(a, b int) (min, max int) {
    if a >= b {
        min = b
        max = a
    } else {
        min = a
        max = b
    }
    return // Without arguments
}
```

І основне - функції також є типом даних, тому їх можна створювати, передавати і приймати:

```go
x := func (a,b int) int { return a + b }
sum := x(5, 10) // sum = 15

```

```go 
package main

import "fmt"

func sum(a,b int) int { return a + b }

func currySum(a int) func(int) int {
    return func(b int) int {
        return sum(a, b)
    }
}


func main() {
    adder5 := currySum(5)
    
    result := adder5(10)
    fmt.Println(result) // Prints 15
}
```