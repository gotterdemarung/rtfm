# Вступ

Мова программування Go наразі є досить зручним та потужним інструментом для розробки 
ефективних та високонавантажених серверних застосунків. Вона ідеально підходить для 
розробки CLI застосунків, мікросервісів, а при використанні IDE GoLand стає можливим
і программування систем будь-якої складності.

Семантично мова схожа на всі C-подібні мови, але всеж має деяку специфіку, взяту із
Ruby/Python, тому деякі речі можуть бути незвичними.


Ця документація призначена для Java-розробників, що мають намір познайомитися із Go.

# Встановлення

На [офіційному сайті Go](https://go.dev/) можна знайти [посилання](https://go.dev/dl/) 
для завантаження Go для будь-якої платформи - Windows, Linux, MacOS. Також отримати
Go можливо за допомогою стандартних пакетних менеджерів, наприклад

- `sudo apt install golang` для Ubuntu
- `brew install golang` для MacOS

Для встановлення рекомендується версія не менша ніж `1.13`, оскільки надалі будуть 
викориростовуватися можливості що доступні починаючи саме із цієї версії.

Корректність установки можна перевірити за допомогою команди `go version`:

```
$ go version
go version go1.18 linux/amd64
```

❗**Go має бути встановлено лише на машині розробника. Після компіляції застосунок 
можна запускати будь-де без встановленого Go.**

# Hello world

## Пишемо, компільюємо та запускаємо
Код, написаний на мові Go розміщується у файлах із розширенням `.go`. Як і в Java, 
код структурований по пакетам і папкам, але у Go не обов'язково, щоб назва папки 
та пакету співпадали (але це дуже бажано). Точкою входу є місцевий аналог 
`public static void main(String args)`, що виглядає наступним чином:
1. Назва пакету - `main`
2. Назва методу - `main`
3. Метод не має аргументів та возврату

Сторимо файл `foo.go`, що задовольняє усім вимогам:

```go
package main

func main() {
}
```

Хоча код і не виконує що-небудь, це - валідний код на Go. 
Для того, щоб скомпілювати його, треба виконати команду `go build foo.go`, в результаті
чого буде створено executable файл `foo` у тій самій директорії. Ім'я можна задати
будь-яке за допомогою флагу `-o`, наприклад `go build -o helloworld foo.go`.

Після компіляції отриманий файл можно запустити як і будь-який інший бінарь
за допомогою `./foo`. Якщо це зробити - команда очіковано не зробить нічного, 
оскільки логіку в код ми ще не добавляли.

Насправді під час розробки Go-девелопери **ніколи не використорують команду** `go build`.
Замість цього повсякчас використовується команда `go run` що робить наступне
1. Компілює наш код в папку `/tmp` або аналог
2. Запускає скомпільований файл
3. Після завершення видаляє створений файл.

Для нашого випадку достатньо запускати наш файл командою `go run foo.go`

## Добавляємо відображення

В Go немає прямого аналогу `System.out.Print`. Але цю роль, та багато інших цікавих
штук може виконувати пакет стандартного форматування `fmt` - саме в ньому знаходяться
`fmt.Println`, `fmt.Printf` а також `fmt.Sprint` (що є аналогом `String.format`).
Як і в Java, в Go для того, щоб використати код із пакету, його треба проімпортувати 
за допомогою команди `import`:

```go
package main

import "fmt"

func main() {
}
```

Якщо добавити `import` та спробувати запустити, ми отримаємо несподівану для своту Java
помилку:

```
$ go run foo.go
./foo.go:3:8: imported and not used: "fmt"
```

Go не дозволяе імпортувати будь-що "просто так" - обов'язково треба використати 
проімпортований пакет:

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}
```

Тепер наш застосунок компілюється і запускається так, як і очікувалось:
```
$ go run foo.go
Hello, world!
```

Правило використовувати проімпортоване в Go є дуже важливим, оскільки весь рантайм та 
стандартний інструментарій подрібнений на пакети і у фінальний бінарь попадають лише
ті, що використовуються у застосунку. Тобто якщо наш застосунок не буде 
використовувати пакет `fmt`, то його взагалі не буде в результуючому бінарі і не можна
буде десь щось дістати навіть за допомогою рефлексії. Навіть якщо у вашому застосунку
буде пакет (папка) із кодом, що не використовується в інших його частинах та функції
`main`, то він не буде скомпільований і не попаде у фінальний бінарь.

До речі, переконатися в правдивості твердження про відсутність `fmt` можна просто 
порівнявши розміри скомпільованих файлів:

```
-rwxrwxr-x user user 1758353 foo     <-- файл у півтора рази більше
-rwxrwxr-x user user 1154527 foo
```

# Змінні

Найпоширеннішим способом оголошення змінної в Go є оголошення із автоматичним виведенням
типу (у Java аналогом є ключове слово `var`). Для цього в Go використовується оператор 
`:=`, наприклад `name := "Some name"`.

Тепер можна параметризувати наш застосунок за допомогою змінної:

```go
package main

import "fmt"

func main() {
	name := "World"
	fmt.Println("Hello, "+name+"!")
}
```

❗ **Важливо**. Go зобов'язує розробника використовувати оголошені змінні. Тобто не
можна оголосити `someValue := "foo"` а потім не використати змінну `someValue` - 
застосунок не скомпілюється

# Nil

В Java є `null`, в Go є `nil`. В принціпе, це все, деталі незначні.

# Типи даних

Усі стандартні типи даних у Go можна розділити на два типи:
1. Референсні (як ті що в Java на хіпі)
2. Примітивні (як ті що в Java на стеку)

До перших відносяться ті, що мають дефолт `nil` - массиви, слайси, мапи, канали, вказівники та функції.

До других - все інше:
- Числові типи
- - Знакові
- - - `int` - Platform dependent, 32/64 bits
- - - `int8`, `int16`, `int32`, `int64`
- - Беззнакові
- - - `uint` - Platform dependent, 32/64 bits
- - - `uint8`, `uint16`, `uint32`, `uint64`
- - - `uintptr`
- - Із рухомою комою, знакові
- - - `float32`, `float64`
- - Комплексні
- - - `complex64`, `complex128`
- - `bool`
- - `byte`
- - `rune` - одна літера, схоже на Java `char`
- - `string` - строка, на відмінність від Java не може бути `nil`

На відміну від Java, тут немає боксових різновидів типів даних, більш того навіть у `string` тут немає
методів/функцій. 
