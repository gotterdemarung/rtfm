# Вступ

Мова программування Go наразі є досить зручним та потужним інструментом для розробки 
ефективних та високонавантажених серверних застосунків. Вона ідеально підходить для 
розробки CLI застосунків, мікросервісів, а при використанні [IDE GoLand](https://www.jetbrains.com/go/) 
стає можливим і программування систем будь-якої складності.

Семантично мова схожа на всі C-подібні мови, але всеж має деяку специфіку, взяту із
Ruby/Python, тому деякі речі можуть бути незвичними - наприклад крапку з комою `;` 
тут використовувати можно, але не рекомендується (за деякими виключеннями), а у 
`if`-операторах вираз не треба брати у скобки.

Ця документація призначена для Java-розробників, що мають намір познайомитися із Go.

# Зміст

- [Вступ](#вступ)
- [Зміст](#зміст)
- [Встановлення](#встановлення)
- [Hello world](#hello-world)
  - [Пишемо, компільюємо та запускаємо](#пишемо-компільюємо-та-запускаємо)
  - [Добавляємо текст](#добавляємо-текст)
- [Змінні](#змінні)
- [Nil](#nil)
- [Типи даних](#типи-даних)
- [Функції](#функції)
- [Массиви](#массиви)
- [Слайси](#слайси)
- [Мапи](#мапи)
- [Структури](#структури)
- [Інтерфейси](#інтерфейси)
- [Помилки](#помилки)
  - [Panic](#panic)
  - [Error](#error)
- [Типи](#типи)
- [Пакети](#пакети)
- [Тестування](#тестування)
- [Багатозадачність](#багатозадачність)

# Встановлення

На [офіційному сайті Go](https://go.dev/) можна знайти [посилання](https://go.dev/dl/) 
для завантаження Go для будь-якої платформи - Windows, Linux, MacOS. Також отримати
Go можливо за допомогою стандартних пакетних менеджерів, наприклад

- `sudo apt install golang` для Ubuntu
- `brew install golang` для MacOS

Для встановлення рекомендується версія не старіша за `1.13`, оскільки надалі будуть 
викориростовуватися можливості що доступні починаючи саме із цієї версії.

Корректність установки можна перевірити за допомогою команди `go version`:

```
$ go version
go version go1.18 linux/amd64
```

❗**Go має бути встановлено лише на машині розробника. Після компіляції застосунок 
можна запускати будь-де без встановленого Go.**

# Hello world

## Пишемо, компільюємо та запускаємо
Код, написаний на мові Go розміщується у файлах із розширенням `.go`. Як і в Java, 
код структурований по пакетам і папкам, але у Go не обов'язково, щоб назва папки 
та пакету співпадали (але це дуже бажано). Точкою входу є місцевий аналог 
`public static void main(String args)`, що виглядає наступним чином:
1. Назва пакету - `main`
2. Назва методу - `main`
3. Метод не має аргументів та возврату

Сторимо файл `foo.go`, що задовольняє усім вимогам:

```go
package main

func main() {
}
```

Хоча код і не виконує будь що, це - валідний код на Go. 
Для того, щоб скомпілювати його, треба виконати команду `go build foo.go`, в результаті
чого буде створено executable файл `foo` у тій самій директорії. Ім'я можна задати
будь-яке за допомогою флагу `-o`, наприклад `go build -o helloworld foo.go`.

Після компіляції отриманий файл можно запустити як і будь-який інший бінарь
за допомогою `./foo`. Якщо це зробити - команда очіковано не зробить нічного, 
оскільки логіку в код ми ще не добавляли.

Насправді під час розробки Go-девелопери **ніколи не використорують команду** `go build`.
Замість цього повсякчас використовується команда `go run` що робить наступне
1. Компілює наш код в папку `/tmp` або аналог
2. Запускає скомпільований файл
3. Після завершення видаляє створений файл.

Для нашого випадку достатньо запускати наш файл командою `go run foo.go`

## Добавляємо текст

В Go немає прямого аналогу `System.out.Print`. Але цю роль, та багато інших цікавих
штук може виконувати пакет стандартного форматування `fmt` - саме в ньому знаходяться
`fmt.Println`, `fmt.Printf` а також `fmt.Sprint` (що є аналогом `String.format`).
Як і в Java, в Go для того, щоб використати код із пакету, його треба проімпортувати 
за допомогою команди `import`:

```go
package main

import "fmt"

func main() {
}
```

Якщо добавити `import` та спробувати запустити, ми отримаємо несподівану для світу Java
помилку:

```
$ go run foo.go
./foo.go:3:8: imported and not used: "fmt"
```

Go не дозволяе імпортувати будь-що "просто так" - обов'язково треба використати 
проімпортований пакет:

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!") // Крапки з комою немає !
}
```

Тепер наш застосунок компілюється і запускається так, як і очікувалось:
```
$ go run foo.go
Hello, world!
```

❗ **Важливо**. 

Правило використовувати проімпортоване в Go є дуже важливим, оскільки весь рантайм та 
стандартний інструментарій подрібнений на пакети і у фінальний бінарь попадають лише
ті, що використовуються у застосунку. Тобто якщо наш застосунок не буде 
використовувати пакет `fmt`, то його взагалі не буде в результуючому бінарі і не можна
буде десь щось дістати навіть за допомогою рефлексії. Також якщо у вашому застосунку
буде пакет (папка) із кодом, що не використовується в інших його частинах та у функції
`main`, то він не буде скомпільований і не попаде у фінальний бінарь.

До речі, переконатися в правдивості твердження про відсутність `fmt` можна просто 
порівнявши розміри скомпільованих файлів:

```
-rwxrwxr-x user user 1758353 foo    [+FMT] <-- файл у півтора рази більше
-rwxrwxr-x user user 1154527 foo    [-FMT]
```

# Змінні

Найпоширеннішим способом оголошення змінної в Go є оголошення із автоматичним виведенням
типу (у Java аналогом є ключове слово `var`). Для цього в Go використовується оператор 
`:=`, наприклад `name := "Some name"`.

Тепер можна параметризувати наш застосунок за допомогою змінної:

```go
package main

import "fmt"

func main() {
	name := "World"
	fmt.Println("Hello, "+name+"!")
}
```

❗ **Важливо**. 

Go зобов'язує розробника використовувати оголошені змінні. Тобто не
можна оголосити `someValue := "foo"` а потім не використати змінну `someValue` - 
застосунок не скомпілюється

# Nil

В Java є `null`, в Go є `nil`. В принціпе, це все, деталі незначні.

# Типи даних

Усі стандартні типи даних у Go можна розділити на чотири типи:
1. **Референсні** (як ті що в Java на хіпі) - ті, що мають дефолт `nil` - массиви, слайси, 
   мапи, канали, вказівники та **функції**
2. **Структури** - це місцеві об'єкти, вони не референсні та не мають конструкторів, щодо
   них пізніше
3. **Фунції** - функцію тут можно як просто виконати, так і передати в іншу функцію
3. **Примітивні** (як ті що в Java на стеку):

- Числові типи
- - Знакові
- - - `int` - 32/64 bits, залежить від платформи 
- - - `int8`, `int16`, `int32`, `int64`
- - Беззнакові
- - - `uint` - 32/64 bits, залежить від платформи 
- - - `uint8`, `uint16`, `uint32`, `uint64`
- - - `uintptr`
- - Із рухомою комою, знакові
- - - `float32`, `float64`
- - Комплексні
- - - `complex64`, `complex128`
- - `bool`
- - `byte`
- - `rune` - одна літера, схоже на Java `char`
- - `string` - строка, на відмінність від Java не може бути `nil`

Основний числовий тип даних, що застосовується в автоматичному виведенні типу це `int`. Тобто конструкція
`i := 0` оголосить змінну з типом `int`.

На відміну від Java, тут немає боксових різновидів типів даних, більш того навіть у `string` тут немає
методів/функцій. 

# Функції

Для оголошення функції використовується ключове слово `func` і ми насправді вже робили
це, оголошуючи головну функцію `main` у [Hello world](#hello-world). Із функціями у Go
є дуже багато специфіки, тому потроху почнемо знайомитися.

До цього ми використовували функцію без аргументів та повернення результатів. У Go, як
і в усіх поважаючих себе мовах, є можливість це робити:

```go
func sum(a int, b int, c int) int {
    return a + b + c
}
```

Зверніть увагу, що тип даних тут вказується після назви вхідної змінної, а не перед, як
це зроблено в Java. Завдяки цьому у випадку, якщо змінні одного типу, тип можна вказувати
один раз:

```go
func sum(a, b, c int) int {
    return a + b + c
}
```

Також супер важливим є те, що Go дозволяє повертати не одне, а будь-яку кількість значень:

```go 
func minMax(a, b int) (int, int) {
    if a >= b {
        return b, a
    }
    return a, b
}

func main() {
    min, max := minMax(10, 8)
    // TODO do something with variables min and max
}
```

Також щоб не заплутатись є можливість вказувати імена для вихіндних значень, однакові типи
також можна не повторювати:

```go 
func minMax(a, b int) (min, max int) {
    if a >= b {
        return b, a
    }
    return a, b
}
```

Оскільки кострукція `(min, max int)` не є декоративною а насправді оголошує змінні, це дозволяє
робити так:

```go 
func minMax(a, b int) (min, max int) {
    if a >= b {
        min = b
        max = a
    } else {
        min = a
        max = b
    }
    return // Without arguments
}
```

І основне - функції також є типом даних, тому їх можна створювати, передавати і приймати:

```go
x := func (a,b int) int { return a + b }
sum := x(5, 10) // sum = 15

```

```go 
package main

import "fmt"

func sum(a,b int) int { return a + b }

func currySum(a int) func(int) int {
    return func(b int) int {
        return sum(a, b)
    }
}


func main() {
    adder5 := currySum(5)
    
    result := adder5(10)
    fmt.Println(result) // Prints 15
}
```

# Массиви

Массиви в Go є і вони ж такі самі як і в Java - треба аллокувати стільки скільки
потрібно і вже потім працювати з ними. На практиці - ніхто їх не використовує,
оскільки слайси їх в багатьох випадках повністю замінюють.

Забудьте про них.

# Слайси

Слайс - це `LinkedList`, що виглядає як массив і є мовною конструкцією Go. Під
капотом має тонну оптимізацій і тому використовується повсюди де тільки можна
замість массивів.

Значення за замовчуванням для будь-якого слайсу це `nil`.

```go
// Створення порожньго слайсу потрібного розміру
// Це не означає, що більше він не стане, але як
// мінімум 10 значень там вже є, у даному випадку
// це нулі
v := make([]int, 10)
// Або можна створити та одночасно заповнити даними
v := []int{4, -3, 42}
// Або можна створити порожній
v := []int{}
```

У слайсів нема методів, тому для того, щоб знайти розмір слайса чи добавити
новий елемент потрібно використовувати спеціальні ключові слова:

```go
// Кількість елементів у слайсі (у Java - .size())
size := len(v)

// Добавити елемент у слайс (у Java - .add())
v = append(v, 8)
```

# Мапи

Мапи, як і слайся, являються мовними конструкціями Go. Також супер оптимізовані та
зустрічаються усюди:

Значення за замовчуванням для будь-якої мапи це `nil`.

```go
// Створення порожньої мапи
m := make(map[int]string)
// Або так
m := map[int]string{}
// Або із ініцілізацією значень
m := map[int]string{
    1: "foo",
    2: "bar",
}
```

У мап також немає методів, тому для визначення розміру треба використовувати оператор
`len(m)`, а для вставки/заміщення елементу - конструкцію виду `m[1] = "hello"`.

Для того, щоб отримати значення мапи по ключу треба просто його прочитати:
```go
value := m[1]
```
Але є ньюанс - якщо спробувати вичитати значення із мапи для не існуючого ключа, мапа
поверне дефолтне значення типу, що використовується для значень мапи:
```go
value := m[999] // value = ""
```
Якщо потрібно вичитати значення із перевіркою існування, Go пропонує використовувати
альтернативний синтаксис із булевою змінною:

```go
m := map[int]string{1: "hello", 3: ""}
value1, ok1 := m[1] // value1="hello" ok1=true
value2, ok2 := m[2] // value2=""      ok2=false
value3, ok3 := m[3] // value3=""      ok3=true
```

❗ **Важливо**

Мапи у Go подібні до `HashMap` у Java, але вбудованих альтернатив `TreeMap` чи
`LinkedHashMap` тут немає. Більш того якщо ітерувати по ключам мапи то вони 
будуть повертатися у довільному порядку і цей порядок буде змінюватися під час
кожного запуску.

Цікавим є те, що ключем мапи може бути (майже) що завгодно і не потрібно 
реалізовувати метод `hashCode`, оскільки Go автоматично рахує хеш і для примітивів
і для більш складних об'єктів


# Структури

Структури - це об'єкти в Go. Відрізняються від об'єктів Java майже усім та досить
непагано показують себе.

Для того, щоб створити (описати) структуру треба застосувати синтаксис 
`type ім'я struct {}` та перерахувати поля структури:

```go
type Point struct {
    x, y int
}
```

У структур немає конструкторів, тому щоб іх інстанціювати треба скористатися однією
із наступних конструкцій:

```go
// Створюємо структуру із значеннями за замовчуванням
// x = 0, y = 0
point1 := Point{}

// Створюємо структуру із передачею значень
// x = 2, y = -3
point2 := Point{2, -3}

// Оскільки попередній синтаксис залежить від порядку оголошення
// філдів у структурі він не рекомендується, краще використовувати
// явне вказання
point3 := Point{x: 6, y: 7}
// Можно і частково
point4 := Point{y: -8}
```

На відмінність від Java, у Go для структур немає необходності робити метод
`equals`, оскільки ця мова автоматично вміє перевіряти рівність структур за
іх наповненням:

```go
fmt.Println(Point{x:2, y:3} == Point{x:2, y:3}) // true
fmt.Println(Point{x:2, y:3} == Point{x:0, y:3}) // false
```

До кожної структури є можливість добавити будь-яку кількість функцій та методів,
але на відмінність від Java методи описуються не усередині сигнатури структури,
а поряд нею. Не обов'язково в тому самому файлі, головне щоб файл із методом
був у тому самому пакеті. 

Для методів також використовується ключове слово `func`, але перед назвою функції
вказується структура до якої цей метод відноситься

```go 
func (this Point) IsZero() bool {
    return this.x == 0 && this.y == 0
}

fmt.Println(Point{x: 2, y: 3}.IsZero()) // false
fmt.Println(Point{x: 0, y: 0}.IsZero()) // true
```

Частина `(this Point)` у сигнатурі функції означає що ця функція є методом структури
Point і дані цієї структури доступні у самій функції у змінній `this`. Хоча 
розробники на Java, C#, JavaScript і звикли до `this`, у Go заборонено використовувати
це йменування - замість нього рекомендується брати першу літеру назви структури, до
якої відноситься цей метод. В нашому випадку для структури Point правильніше 
наступне:

```go 
func (p Point) IsZero() bool {
    return p.x == 0 && p.y == 0
}
```

❗ **Важливо пам'ятати, що структури - це не об'єкти, до яких ми звикли в Java, а саме 
структури**. У методі `IsZero` у змінну `p Point` втрапляє не референс на об'ект, а
копія самої структури, тобто двох ії полів. Те ж саме буде траплятися, якщо буде 
створена функція, що приймає на вхід `Point` - при передачі буде зроблена копія
данних яку й отримає функція. 

Виглядає так, ніби ми дуже неефективно використовуємо пам'ять - постійні аллокації
для копій, потім іх знищення після виходу з функції. Але у живому застосунку, у 
реальних, а не синтетичних обставинах, все із точністю до навпаки - за рахунок такої
поведінки у рази зменшується навантаження на garbage collector, більшість даних при
грамотному плануванні навіть не попадає у "хіп" а народжується і помирає на стеку.
Також це неймовірно зручно для мультизадачності, оскільки зникає можливість 
виникнення race condition.

Звучить круто, а як тоді бути із сеттерами виду:

```go
func (p Point) SetX(x int) {
    p.x = x
}
```

Так, у такому вигляді сеттер дійсно працювати не буде. Якщо визвати метод `.SetX(12345)` 
для будь-якого інстансу Point його внутрішній стан не буде змінюватись, оскільки у
метод буде передана копія.

Вихід із ситуації - прокидувати у метод не саму структуру, а вказівник (указатель, pointer)
на структуру. Для цього треба поставити перед структурою `*`:

```go 
func (p *Point) SetX(x int) {
    p.x = x
}
```

Такий сеттер буде працювати так, як і було заплановано - структура копіюватися не буде.
Взагалі-то передавати вказівник, а не саму структуру можно усюди, навіть для геттерів і 
в такому випадку дані копіюватися не будуть, але самі розробники Go проводили тестування 
та стверджують що це - неефективно. Тому в загальному випадку вказівника треба уникати, 
окрім наступних випадків:
- Нам дійсно потрібно модифікувати дані у структурі
- Усередині структури знаходяться дані, яки не будуть правильно працювати при 
  копіюванні - наприклад `sync.Mutex` також скопіюється і не буде надавали
  блокування як потрібно
- Структура настільки велика що її копіювання дійсно шкодить роботі застосунка  

❗ **У Go немає наслідування**

# Інтерфейси

Як і в Java, тут інтерфейси виконують функцію контракту, але на відмінність від усіх
ішних мов программування тут використовується принцип **duck typing**. Тобто 
оголосити інтерфейс можна, але ключового слова `implements` або `extends` тут намає - 
натомість абсолютно всі стуктури (та й типи взагалі) що мають методи, описані в 
інтерфейсі його автоматично імплементять. Це неймовірно зручно та гнучко з точки зору
інтероперабельності разних ліб, але для того, щоб знайти усіх імплементаторів інтерфейсу
тут необхідно використовувати IDE на кшталт GoLand.

Повертаючись до duck typing:

```go
type XSetter interface {
    SetX(int)
}

func main() {
    p := &Point{x: 10, y: 15}
    setXCoordinateToZero(p)
}

func setXCoordinateToZero(x XSetter) {
    x.SetX(0)
}
```

Ми нічого не змінювали у стуктурі `Point`, вона автоматично стала імплементити 
новостворений інтерфейс `XSetter`, що надало можливість передати вказівник на наш Point
до функції setXCoordinateToZero.

❗ **Що ще потрібно знати про інтерфейси**:
- Слайс або массив, або мапа будь-якого типу не може автоматично бути представлена як 
  слайс/масив/мапа інтерфейсу навідь якщо тип і імплементить цей інтерфейс. У нашому 
  випадку слайс `[]*Point` не дорівнює слайсу `[]XSetter` - це пов'язано із 
  спеціфікою роботи із пам'яттю та зберіганням інтерфейсів у ній.
- Є можливість оголошувати порожній інтерфейс `interface{}` - в такому випадку будь-що 
  може бути записано в таку змінну або аргумент функції. Найближчий аналог із світу
  Java це `Object`, але тут це значно ширша штука.
- Go дозволяє оголошувати інтерфейси inline, наприклад прямо у сигнатурі функції, наприклад
  `setXCoordinateToZero(x interface{SetX(int)})` також корректно би працював. І хоча 
  inline оголошення інтерфейсів зустрічається досить рідко, оголошення порожніх інтерфейсів
  у функціях зустрічіється повсякчас, наприклад для функції що приймає що завгодно на вході
  `func anything(x interface{})`
- Якщо на вхід функції попадає інтерфейс, треба розуміти що туди може влетіти і `nil`, тому -
  треба робити перевірки
- Оголошення `interface{}` використовуєтсья настільки часто, що починаючи з Go `1.18` для 
  цього зробили аліас `any`

# Помилки

Go має два механізми роботи з помилками.

## Panic

`panic` це майже те саме, щой і `throw`, але замість exception до нього можно передати що завгодно.
Та на відмінність від Java тут немає `catch/finally` блоків тому panic неможливо (майже) відловити
і тому зазвичай він призводить до зупинення застосунку.

Тому у повсякденному житті Go розробники не використовують `panic`, ніколи.

## Error

`error` - це дуже простий інтерфейс, що постачається разом із Go. Він має наступний вигляд:

```go
type error interface {
    Error() string
}
```

Тобто - помилкою з точки зору Go являється будь-що, що має метод з назвою `Error()` та повертає
`string`. Немає ні стейтрейсу, ні `cause` - хоча ніщо не заважає нам самим написати структуру, 
що буде імплементувати інтерфейс `error`.

❗ **Замість того, щоб бросати помилки, у Go функції їх повертають. Так - це дуже незвично**

Завдяки тому, що функції в Go можуть повертати будь-яку кількість значень, у Go існує контракт, 
за яким якщо функція може завершитися із помилкою, вона має повернути її останням значенням 

Наприклад у пакеті `io/ioutil` є функція що вичитує файл:

```go
// bts - байти з файлу, err - помилка
bts, err := ioutil.ReadFile("README.md")
if err != nil {
    // Тут має знаходитися логіка обробки помилки
}
```

Для створення помилки можна написати свою структуру, або використати пакет `errors`:

```go
func divide(a, b float64) (float64, error) {
    if b==0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a/b, nil
}
```

# Типи

Ключове слово `type` ми вже використовували - для оголошення структур та інтерфейсів. 
Також за допомогою нього можна робити фунціональні інтерфейси, або аліаси до
складних функцій:

```go
// Будь-яка функція, що не має аргументів та повертає
// строку є RayIdProvider
type RayIdProvider func() string
```

Ще одне використання - створювати enum:

```go
type Status int

const (
    Success    Status = 1
    Failed     Status = 2
    InProgress Status = 3
    Pending    Status = 4
)
```

Не зважаючи на те, що всередині `Status` той самий `int`, але це вже зовсім інший тип
даних, який ми можемо декларувати на вхід чи віхід функцій та використовувати у полях
структур. Як і у випадку із структурами, ми маємо можливість добавляти методи:

```go
func (s Status) IsTerminal() bool {
    return s == Success || s == Failed
}
```

Go дозволяє конвертувати типи між собою, але не всі:
- Числові можно перетворювати між собою
- Строки можна перетворювати на байти та навпаки
- У кастомний тип можна сконвертувати із базового
- Із строки в число та навпаки сконверувати не можна

У загальному випадку конвертування має вигляд `новий_тип(старий_тип)` - схоже на те, що
в Java робить конструктор:

```go
// Строка
s := "Hello, world"
// Конвертуємо в байти
bts := []byte(s)
// А тепер назад
s = string(bts)

i := 4
st := Status(i) // Отримуємо фактично статус Pending

// Добавляємо getter для отримання int із нашого типу
func (s Status) IntValue() int {
    return int(s)
}
```

# Пакети

# Тестування

# Багатозадачність