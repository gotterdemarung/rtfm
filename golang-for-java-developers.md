# Вступ

Мова программування Go наразі є досить зручним та потужним інструментом для розробки 
ефективних та високонавантажених серверних застосунків. Вона ідеально підходить для 
розробки CLI застосунків, мікросервісів, а при використанні IDE GoLand стає можливим
і программування систем будь-якої складності.

Семантично мова схожа на всі C-подібні мови, але всеж має деяку специфіку, взяту із
Ruby/Python, тому деякі речі можуть бути незвичними.


Ця документація призначена для Java-розробників, що мають намір познайомитися із Go.

# Зміст

- [Вступ](#вступ)
- [Зміст](#зміст)
- [Встановлення](#встановлення)
- [Hello world](#hello-world)
  - [Пишемо, компільюємо та запускаємо](#пишемо-компільюємо-та-запускаємо)
  - [Добавляємо текст](#добавляємо-текст)
- [Змінні](#змінні)
- [Nil](#nil)
- [Типи даних](#типи-даних)
- [Функції](#функції)
- [Структури](#структури)

# Встановлення

На [офіційному сайті Go](https://go.dev/) можна знайти [посилання](https://go.dev/dl/) 
для завантаження Go для будь-якої платформи - Windows, Linux, MacOS. Також отримати
Go можливо за допомогою стандартних пакетних менеджерів, наприклад

- `sudo apt install golang` для Ubuntu
- `brew install golang` для MacOS

Для встановлення рекомендується версія не менша ніж `1.13`, оскільки надалі будуть 
викориростовуватися можливості що доступні починаючи саме із цієї версії.

Корректність установки можна перевірити за допомогою команди `go version`:

```
$ go version
go version go1.18 linux/amd64
```

❗**Go має бути встановлено лише на машині розробника. Після компіляції застосунок 
можна запускати будь-де без встановленого Go.**

# Hello world

## Пишемо, компільюємо та запускаємо
Код, написаний на мові Go розміщується у файлах із розширенням `.go`. Як і в Java, 
код структурований по пакетам і папкам, але у Go не обов'язково, щоб назва папки 
та пакету співпадали (але це дуже бажано). Точкою входу є місцевий аналог 
`public static void main(String args)`, що виглядає наступним чином:
1. Назва пакету - `main`
2. Назва методу - `main`
3. Метод не має аргументів та возврату

Сторимо файл `foo.go`, що задовольняє усім вимогам:

```go
package main

func main() {
}
```

Хоча код і не виконує що-небудь, це - валідний код на Go. 
Для того, щоб скомпілювати його, треба виконати команду `go build foo.go`, в результаті
чого буде створено executable файл `foo` у тій самій директорії. Ім'я можна задати
будь-яке за допомогою флагу `-o`, наприклад `go build -o helloworld foo.go`.

Після компіляції отриманий файл можно запустити як і будь-який інший бінарь
за допомогою `./foo`. Якщо це зробити - команда очіковано не зробить нічного, 
оскільки логіку в код ми ще не добавляли.

Насправді під час розробки Go-девелопери **ніколи не використорують команду** `go build`.
Замість цього повсякчас використовується команда `go run` що робить наступне
1. Компілює наш код в папку `/tmp` або аналог
2. Запускає скомпільований файл
3. Після завершення видаляє створений файл.

Для нашого випадку достатньо запускати наш файл командою `go run foo.go`

## Добавляємо текст

В Go немає прямого аналогу `System.out.Print`. Але цю роль, та багато інших цікавих
штук може виконувати пакет стандартного форматування `fmt` - саме в ньому знаходяться
`fmt.Println`, `fmt.Printf` а також `fmt.Sprint` (що є аналогом `String.format`).
Як і в Java, в Go для того, щоб використати код із пакету, його треба проімпортувати 
за допомогою команди `import`:

```go
package main

import "fmt"

func main() {
}
```

Якщо добавити `import` та спробувати запустити, ми отримаємо несподівану для своту Java
помилку:

```
$ go run foo.go
./foo.go:3:8: imported and not used: "fmt"
```

Go не дозволяе імпортувати будь-що "просто так" - обов'язково треба використати 
проімпортований пакет:

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!") // Крапки з комою немає !
}
```

Тепер наш застосунок компілюється і запускається так, як і очікувалось:
```
$ go run foo.go
Hello, world!
```

❗ **Важливо**. 

Правило використовувати проімпортоване в Go є дуже важливим, оскільки весь рантайм та 
стандартний інструментарій подрібнений на пакети і у фінальний бінарь попадають лише
ті, що використовуються у застосунку. Тобто якщо наш застосунок не буде 
використовувати пакет `fmt`, то його взагалі не буде в результуючому бінарі і не можна
буде десь щось дістати навіть за допомогою рефлексії. Навіть якщо у вашому застосунку
буде пакет (папка) із кодом, що не використовується в інших його частинах та функції
`main`, то він не буде скомпільований і не попаде у фінальний бінарь.

До речі, переконатися в правдивості твердження про відсутність `fmt` можна просто 
порівнявши розміри скомпільованих файлів:

```
-rwxrwxr-x user user 1758353 foo    [+FMT] <-- файл у півтора рази більше
-rwxrwxr-x user user 1154527 foo    [-FMT]
```

# Змінні

Найпоширеннішим способом оголошення змінної в Go є оголошення із автоматичним виведенням
типу (у Java аналогом є ключове слово `var`). Для цього в Go використовується оператор 
`:=`, наприклад `name := "Some name"`.

Тепер можна параметризувати наш застосунок за допомогою змінної:

```go
package main

import "fmt"

func main() {
	name := "World"
	fmt.Println("Hello, "+name+"!")
}
```

❗ **Важливо**. 

Go зобов'язує розробника використовувати оголошені змінні. Тобто не
можна оголосити `someValue := "foo"` а потім не використати змінну `someValue` - 
застосунок не скомпілюється

# Nil

В Java є `null`, в Go є `nil`. В принціпе, це все, деталі незначні.

# Типи даних

Усі стандартні типи даних у Go можна розділити на два типи:
1. **Референсні** (як ті що в Java на хіпі) - ті, що мають дефолт `nil` - массиви, слайси, 
   мапи, канали, вказівники та **функції**
2. **Структури** - це місцеві об'єкти, вони не референсні та не мають конструкторів, щодо
   них пізніше
3. **Примітивні** (як ті що в Java на стеку):

- Числові типи
- - Знакові
- - - `int` - 32/64 bits, залежить від платформи 
- - - `int8`, `int16`, `int32`, `int64`
- - Беззнакові
- - - `uint` - 32/64 bits, залежить від платформи 
- - - `uint8`, `uint16`, `uint32`, `uint64`
- - - `uintptr`
- - Із рухомою комою, знакові
- - - `float32`, `float64`
- - Комплексні
- - - `complex64`, `complex128`
- - `bool`
- - `byte`
- - `rune` - одна літера, схоже на Java `char`
- - `string` - строка, на відмінність від Java не може бути `nil`

Основний числовий тип даних, що застосовується в автоматичному виведенні типу це `int`. Тобто конструкція
`i := 0` оголосить змінну з типом `int`.

На відміну від Java, тут немає боксових різновидів типів даних, більш того навіть у `string` тут немає
методів/функцій. 

# Функції

Для оголошення функції використовується ключове слово `func` і ми насправді вже робили
це, оголошуючи головну функцію `main` у [Hello world](#hello-world). Із функціями у Go
є дуже багато специфіки, тому потроху почнемо знайомитися.

До цього ми використовували функцію без аргументів та повернення результатів. У Go, як
і в усіх поважаючих себе мовах, є можливість це робити:

```go
func sum(a int, b int, c int) int {
    return a + b + c
}
```

Зверніть увагу, що тип даних тут вказується після назви вхідної змінної, а не перед, як
це зроблено в Java. Завдяки цьому у випадку, якщо змінні одного типу, тип можна вказувати
один раз:

```go
func sum(a, b, c int) int {
    return a + b + c
}
```

Також супер важливим є те, що Go дозволяє повертати не одне, а будь-яку кількість значень:

```go 
func minMax(a, b int) (int, int) {
    if a >= b {
        return b, a
    }
    return a, b
}

func main() {
    min, max := minMax(10, 8)
    // TODO do something with variables min and max
}
```

Також щоб не заплутатись є можливість вказувати імена для вихіндних значень, однакові типи
також можна не повторювати:

```go 
func minMax(a, b int) (min, max int) {
    if a >= b {
        return b, a
    }
    return a, b
}
```

Оскільки кострукція `(min, max int)` не є декоративною а насправді оголошує змінні, це дозволяє
робити так:

```go 
func minMax(a, b int) (min, max int) {
    if a >= b {
        min = b
        max = a
    } else {
        min = a
        max = b
    }
    return // Without arguments
}
```

І основне - функції також є типом даних, тому їх можна створювати, передавати і приймати:

```go
x := func (a,b int) int { return a + b }
sum := x(5, 10) // sum = 15

```

```go 
package main

import "fmt"

func sum(a,b int) int { return a + b }

func currySum(a int) func(int) int {
    return func(b int) int {
        return sum(a, b)
    }
}


func main() {
    adder5 := currySum(5)
    
    result := adder5(10)
    fmt.Println(result) // Prints 15
}
```

# Структури

Структури - це об'єкти в Go. Відрізняються від об'єктів Java майже усім та досить
непагано показують себе.

Для того, щоб створити (описати) структуру треба застосувати синтаксис 
`type ім'я struct {}` та перерахувати поля структури:

```go
type Point struct {
    x, y int
}
```

У структур немає конструкторів, тому щоб іх інстанціювати треба скористатися однією
із наступних конструкцій:

```go
// Створюємо структуру із значеннями за замовчуванням
// x = 0, y = 0
point1 := Point{}

// Створюємо структуру із передачею значень
// x = 2, y = -3
point2 := Point{2, -3}

// Оскільки попередній синтаксис залежить від порядку оголошення
// філдів у структурі він не рекомендується, краще використовувати
// явне вказання
point3 := Point{x: 6, y: 7}
// Можно і частково
point4 := Point{y: -8}
```

На відмінність від Java, у Go для структур немає необходності робити метод
`equals`, оскільки ця мова автоматично вміє перевіряти рівність структур за
іх наповненням:

```go
fmt.Println(Point{x:2, y:3} == Point{x:2, y:3}) // true
fmt.Println(Point{x:2, y:3} == Point{x:0, y:3}) // false
```

До кожної структури є можливість добавити будь-яку кількість функцій та методів,
але на відмінність від Java методи описуються не усередині сигнатури структури,
а поряд нею. Не обов'язково в тому самому файлі, головне щоб файл із методом
був у тому самому пакеті. 

Для методів також використовується ключове слово `func`, але перед назвою функції
вказується структура до якої цей метод відноситься

```go 
func (this Point) IsZero() bool {
    return this.x == 0 && this.y == 0
}

fmt.Println(Point{x: 2, y: 3}.IsZero()) // false
fmt.Println(Point{x: 0, y: 0}.IsZero()) // true
```

Частина `(this Point)` у сигнатурі функції означає що ця функція є методом структури
Point і дані цієї структури доступні у самій функції у змінній `this`. Хоча 
розробники на Java, C#, JavaScript і звикли до `this`, у Go наборонено використовувати
це йменування - замість нього рекомендується брати першу літеру назви структури, до
якої відноситься цей метод. В нашому випадку для структури Point правильніше 
наступне:

```go 
func (p Point) IsZero() bool {
    return p.x == 0 && p.y == 0
}
```

❗ **Важливо пам'ятати, що структури - це не об'єкти, до яких ми звикли в Java, а саме 
структури**. У методі `IsZero` у змінну `p Point` втрапляє не референс на об'ект, а
копія самої структури, тобто двох ії полів. Те ж саме буде траплятися, якщо буде 
створена функція, що приймає на вхід `Point` - при передачі буде зроблена копія
данних яку й отримає функція. 

Виглядає так, ніби ми дуже неефективно використовуємо пам'ять - постійні аллокації
для копій, потім іх знищення після виходу з функції. Але у живому застосунку, у 
реальних, а не синтетичних обставинах, все із точністю до навпаки - за рахунок такої
поведінки у рази зменшується навантаження на garbage collector, більшість даних при
грамотному плануванні навіть не попадає у "хіп" а народжується і помирає на стеку.

Звучить круто, а як тоді бути із сеттерами виду:

```go
func (p Point) SetX(x int) {
    p.x = x
}
```

Так, у такому вигляді сеттер дійсно працювати не буде. Якщо визвати метод `.SetX(12345)` 
для будь-якого інстансу Point його внутрішній стан не буде змінюватись, оскільки у
метод буде передана копія.

Вихід із ситуації - прокидувати у метод не саму структуру, а вказівник (указатель, pointer)
на структуру. Для цього треба поставити перед структурою `*`:

```go 
func (p *Point) SetX(x int) {
    p.x = x
}
```

Такий сеттер буде працювати так, як і було заплановано - структура копіюватися не буде.
Взагало-то передавати вказівник, а не саму структуру можно усюди, навіть для геттерів і 
в такому випадку дані копіюватися не будуть, але самі розробники Go проводили тестування 
та стверджують що це - неефективно. Тому в загальному випадку вказівника треба уникати, 
окрім наступних випадків:
- Нам дійсно потрібно модифікувати дані у структурі
- Усередині структури знаходяться дані, яки не будуть правильно працювати при 
  копіюванні - наприклад `sync.Mutex` також скопіюється і не буде надавали
  блокування як потрібно
- Структура настільки велика що її копіювання дійсно шкодить роботі застосунка  